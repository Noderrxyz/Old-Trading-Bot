syntax = "proto3";

package noderr.trading;

option go_package = "github.com/noderr/trading/proto";
option java_multiple_files = true;
option java_package = "io.noderr.trading.proto";
option java_outer_classname = "NoderrTradingProto";

// Common messages used across services
import "google/protobuf/timestamp.proto";
import "google/protobuf/struct.proto";

// =============================================================
// Common Message Types
// =============================================================

// Authentication header for all communication
message AuthHeader {
    string node_id = 1;
    int64 timestamp = 2;
    bytes signature = 3; // Signature of node_id + timestamp
    string version = 4;  // Protocol version
}

// Identity information for a node
message NodeIdentity {
    string node_id = 1;
    string node_type = 2; // "ORACLE", "GUARDIAN", "VALIDATOR", "MICRO"
    bytes public_key = 3;
    string network_address = 4;
    map<string, string> metadata = 5;
    int32 protocol_version = 6;
}

// Status of an operation
enum Status {
    STATUS_UNKNOWN = 0;
    STATUS_SUCCESS = 1;
    STATUS_FAILED = 2;
    STATUS_PENDING = 3;
    STATUS_TIMEOUT = 4;
    STATUS_REJECTED = 5;
    STATUS_PARTIAL = 6;
}

// Standard error response
message ErrorResponse {
    string error_code = 1;
    string message = 2;
    map<string, string> details = 3;
}

// Standard response wrapper
message Response {
    Status status = 1;
    string message = 2;
    google.protobuf.Struct data = 3; // Flexible response data
    ErrorResponse error = 4; // Present only on failure
}

// =============================================================
// Strategy-Related Messages
// =============================================================

// Trading action enumeration
enum SignalAction {
    SIGNAL_ACTION_UNKNOWN = 0;
    SIGNAL_ACTION_BUY = 1;
    SIGNAL_ACTION_SELL = 2;
    SIGNAL_ACTION_LONG_ENTRY = 3;
    SIGNAL_ACTION_LONG_EXIT = 4;
    SIGNAL_ACTION_SHORT_ENTRY = 5;
    SIGNAL_ACTION_SHORT_EXIT = 6;
}

// A trading signal generated by a strategy
message TradingSignal {
    string signal_id = 1;
    string strategy_id = 2;
    google.protobuf.Timestamp timestamp = 3;
    string symbol = 4;
    SignalAction action = 5;
    double quantity = 6;
    optional double price_limit = 7;
    float urgency = 8; // 0.0-1.0
    int32 ttl_seconds = 9;
    map<string, google.protobuf.Value> parameters = 10;
    AuthHeader auth = 11;
}

// Result of a signal execution
message ExecutionResult {
    string signal_id = 1;
    google.protobuf.Timestamp timestamp = 2;
    string status = 3; // "FILLED", "PARTIAL", "FAILED", "EXPIRED", "REJECTED"
    double filled_quantity = 4;
    double executed_price = 5;
    double fees = 6;
    int32 latency_ms = 7;
    map<string, google.protobuf.Value> metadata = 8;
}

// Strategy proposal from one node to another
message StrategyProposal {
    AuthHeader auth = 1;
    string proposal_id = 2;
    string strategy_name = 3;
    string author = 4;
    string description = 5;
    bytes strategy_code = 6;
    string strategy_language = 7; // "PYTHON", "RUST", etc.
    map<string, string> parameters = 8;
    bytes test_results = 9; // Optional pre-test results
    google.protobuf.Timestamp created_at = 10;
    string version = 11;
    // Hash for verification
    bytes code_hash = 12;
}

// Response to a strategy proposal
message ProposalResponse {
    string proposal_id = 1;
    Status status = 2;
    string message = 3;
    int64 governance_id = 4; // If accepted, the governance proposal ID
}

// Request to test a strategy
message StrategyTest {
    AuthHeader auth = 1;
    string strategy_id = 2;
    bytes strategy_code = 3;
    string strategy_language = 4;
    map<string, string> parameters = 5;
    string test_type = 6; // "BACKTEST", "SIMULATION", "LIVE_TEST"
    int64 test_duration = 7; // Duration in seconds
    bytes market_data = 8; // Optional test data
    bool use_real_market_data = 9;
    string start_date = 10; // For backtests with historical data
    string end_date = 11;   // For backtests with historical data
}

// Result of a strategy test
message TestResult {
    string test_id = 1;
    string strategy_id = 2;
    Status status = 3;
    double profit_loss = 4;
    double max_drawdown = 5;
    double sharpe_ratio = 6;
    int32 trade_count = 7;
    double win_rate = 8;
    map<string, double> metrics = 9; // Additional metrics
    google.protobuf.Timestamp completed_at = 10;
    bytes detailed_results = 11; // Serialized detailed results
}

// Request for performance data
message PerformanceRequest {
    AuthHeader auth = 1;
    string strategy_id = 2;
    google.protobuf.Timestamp start_time = 3;
    google.protobuf.Timestamp end_time = 4;
    int32 max_results = 5;
}

// Performance update for a strategy
message PerformanceUpdate {
    string strategy_id = 1;
    google.protobuf.Timestamp timestamp = 2;
    int32 trades_count = 3;
    double profit_loss = 4;
    double current_drawdown = 5;
    map<string, double> metrics = 6;
}

// =============================================================
// Trust-Related Messages
// =============================================================

// Request for trust attestation
message TrustRequest {
    AuthHeader auth = 1;
    string node_id = 2;
}

// Trust attestation response
message TrustAttestation {
    string attester_id = 1;
    string node_id = 2;
    int32 trust_score = 3; // 0-100
    google.protobuf.Timestamp timestamp = 4;
    bytes signature = 5; // Signature of all fields above
    int64 valid_until = 6; // Unix timestamp of expiration
}

// Update a node's trust score
message TrustScoreUpdate {
    AuthHeader auth = 1;
    string node_id = 2;
    int32 previous_score = 3;
    int32 new_score = 4;
    string reason = 5;
    bytes evidence = 6; // Optional supporting evidence
    google.protobuf.Timestamp timestamp = 7;
}

// Response to trust score update
message TrustUpdateResponse {
    Status status = 1;
    string message = 2;
    int32 confirmed_score = 3;
}

// Request to stream trust updates
message TrustStreamRequest {
    AuthHeader auth = 1;
    google.protobuf.Timestamp since = 2;
    repeated string node_ids = 3; // Optional filter by node IDs
    int32 min_score_change = 4; // Only stream changes >= this amount
}

// =============================================================
// Execution-Related Messages
// =============================================================

// Request to execute a trade
message TradeExecution {
    AuthHeader auth = 1;
    TradingSignal signal = 2;
    string execution_strategy = 3; // e.g., "MARKET", "LIMIT", "TWAP"
    map<string, google.protobuf.Value> execution_parameters = 4;
    int64 max_slippage_bps = 5; // Maximum allowed slippage in basis points
    bool allow_partial = 6;
    int32 timeout_ms = 7;
}

// Response from a routing request
message RoutingResponse {
    Status status = 1;
    string message = 2;
    string route_id = 3;
    repeated string execution_nodes = 4; // IDs of nodes handling execution
    int32 estimated_latency_ms = 5;
}

// Register a Micro node with a Guardian
message MicroNodeRegistration {
    AuthHeader auth = 1;
    NodeIdentity node_identity = 2;
    repeated string supported_exchanges = 3;
    repeated string supported_assets = 4;
    map<string, google.protobuf.Value> capabilities = 5;
    int32 max_concurrent_executions = 6;
}

// Response to node registration
message RegistrationResponse {
    Status status = 1;
    string message = 2;
    string registry_id = 3;
    google.protobuf.Timestamp expiration = 4; // When this registration expires
    bytes credentials = 5; // Optional credentials for future auth
}

// Status report from a Micro node
message StatusReport {
    AuthHeader auth = 1;
    string node_id = 2;
    float cpu_usage = 3;
    float memory_usage = 4;
    int32 active_executions = 5;
    int32 completed_executions = 6;
    int32 failed_executions = 7;
    google.protobuf.Timestamp timestamp = 8;
    Status node_status = 9;
    string version = 10;
    map<string, google.protobuf.Value> metrics = 11;
}

// Acknowledgement of a status report
message StatusAcknowledgement {
    Status status = 1;
    string message = 2;
    bool should_update = 3;
    string update_url = 4; // URL for update if needed
}

// =============================================================
// Governance-Related Messages
// =============================================================

// Governance vote from a node
message GovernanceVote {
    AuthHeader auth = 1;
    int64 proposal_id = 2;
    bool support = 3;
    string reason = 4;
    bytes signature = 5; // Signature of vote
}

// Response to a vote submission
message VoteResponse {
    Status status = 1;
    string message = 2;
    int64 proposal_id = 3;
    int32 votes_for = 4;
    int32 votes_against = 5;
    bool quorum_reached = 6;
}

// =============================================================
// Service Definitions
// =============================================================

// Oracle node service
service OracleService {
    // Submit a strategy proposal from one Oracle to another
    rpc ProposeStrategy(StrategyProposal) returns (ProposalResponse);
    
    // Stream strategy performance updates
    rpc StreamPerformance(PerformanceRequest) returns (stream PerformanceUpdate);
    
    // Request trust attestation from Oracle
    rpc GetTrustAttestation(TrustRequest) returns (TrustAttestation);
    
    // Get the current state of a strategy
    rpc GetStrategyState(StrategyRequest) returns (StrategyState);
    
    // Synchronize strategies between Oracle nodes
    rpc SynchronizeStrategies(SyncRequest) returns (SyncResponse);
}

// Validator node service
service ValidatorService {
    // Test a strategy in the Validator sandbox
    rpc TestStrategy(StrategyTest) returns (TestResult);
    
    // Update a node's trust score
    rpc UpdateTrustScore(TrustScoreUpdate) returns (TrustUpdateResponse);
    
    // Stream trust updates from a Validator
    rpc StreamTrustUpdates(TrustStreamRequest) returns (stream TrustScoreUpdate);
    
    // Validate a trading signal before execution
    rpc ValidateSignal(TradingSignal) returns (ValidationResult);
    
    // Report a node's behavior for trust evaluation
    rpc ReportNodeBehavior(BehaviorReport) returns (Response);
}

// Guardian node service
service GuardianService {
    // Route a trading signal via Guardian
    rpc RouteSignal(TradingSignal) returns (RoutingResponse);
    
    // Register a Micro node with a Guardian
    rpc RegisterMicroNode(MicroNodeRegistration) returns (RegistrationResponse);
    
    // Submit a governance vote
    rpc SubmitVote(GovernanceVote) returns (VoteResponse);
    
    // Stream execution results for signals
    rpc StreamExecutionResults(ExecutionStreamRequest) returns (stream ExecutionResult);
    
    // Fetch available Micro nodes matching criteria
    rpc GetAvailableMicroNodes(MicroNodeRequest) returns (MicroNodeList);
}

// Micro node service
service MicroService {
    // Execute a trade via Micro node
    rpc ExecuteTrade(TradeExecution) returns (ExecutionResult);
    
    // Report Micro node status
    rpc ReportStatus(StatusReport) returns (StatusAcknowledgement);
    
    // Check if Micro node is alive and ready
    rpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse);
}

// Additional messages for service interfaces
message StrategyRequest {
    AuthHeader auth = 1;
    string strategy_id = 2;
}

message StrategyState {
    string strategy_id = 1;
    string name = 2;
    Status status = 3;
    google.protobuf.Timestamp last_execution = 4;
    int32 executions_count = 5;
    double current_profit_loss = 6;
    map<string, google.protobuf.Value> state = 7;
}

message SyncRequest {
    AuthHeader auth = 1;
    google.protobuf.Timestamp since = 2;
    repeated string strategy_ids = 3; // Empty means all strategies
}

message SyncResponse {
    Status status = 1;
    string message = 2;
    repeated StrategyState strategies = 3;
    int32 total_count = 4;
    bool has_more = 5;
}

message ValidationResult {
    Status status = 1;
    string message = 2;
    repeated string validation_issues = 3;
    int32 risk_score = 4; // 0-100, higher means riskier
}

message BehaviorReport {
    AuthHeader auth = 1;
    string node_id = 2;
    string behavior_type = 3; // "LATENCY", "ERROR", "SLIPPAGE", etc.
    int32 severity = 4; // 1-10
    string description = 5;
    bytes evidence = 6;
    google.protobuf.Timestamp timestamp = 7;
}

message ExecutionStreamRequest {
    AuthHeader auth = 1;
    repeated string strategy_ids = 2;
    google.protobuf.Timestamp since = 3;
}

message MicroNodeRequest {
    AuthHeader auth = 1;
    repeated string required_exchanges = 2;
    repeated string required_assets = 3;
    int32 min_trust_score = 4;
    int32 max_results = 5;
}

message MicroNodeList {
    repeated NodeIdentity nodes = 1;
    int32 total_count = 2;
}

message HealthCheckRequest {
    AuthHeader auth = 1;
    bool detailed = 2;
}

message HealthCheckResponse {
    Status status = 1;
    string message = 2;
    int64 timestamp = 3;
    map<string, google.protobuf.Value> details = 4;
} 