#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# SPDX-License-Identifier: MIT
#
# Copyright (c) 2025 Noderr Protocol Foundation
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

"""
Base classes and data structures for Noderr strategies implemented in Python.
These work with the Rust core through a well-defined API.
"""

from dataclasses import dataclass, field
from typing import List, Dict, Optional, Union, Any, Literal
from datetime import datetime
import uuid
import logging
import numpy as np
from abc import ABC, abstractmethod

logger = logging.getLogger(__name__)

@dataclass
class MarketData:
    """Rich market data structure consumed by strategies."""
    timestamp: datetime
    symbol: str
    price: float
    volume: float
    orderbook: Dict[str, List[Dict[str, float]]]
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    # Additional fields for technical analysis
    candles: Optional[List[Dict[str, Any]]] = None
    indicators: Dict[str, Any] = field(default_factory=dict)
    sentiment: Optional[Dict[str, float]] = None
    
    def __post_init__(self):
        """Validate and process the market data after initialization."""
        # Ensure orderbook has proper structure
        if not all(side in self.orderbook for side in ['bids', 'asks']):
            logger.warning(f"Orderbook for {self.symbol} missing bids or asks")
            # Initialize empty sides if missing
            if 'bids' not in self.orderbook:
                self.orderbook['bids'] = []
            if 'asks' not in self.orderbook:
                self.orderbook['asks'] = []

@dataclass
class Signal:
    """Trading signal generated by a strategy."""
    strategy_id: str
    timestamp: datetime
    symbol: str
    action: Literal["BUY", "SELL", "LONG_ENTRY", "LONG_EXIT", "SHORT_ENTRY", "SHORT_EXIT"]
    quantity: float
    
    # Optional fields with default values
    price_limit: Optional[float] = None
    urgency: float = 0.5  # 0.0 to 1.0, affects execution priority
    ttl_seconds: int = 60  # Time-to-live for the signal
    parameters: Dict[str, Any] = field(default_factory=dict)
    
    # Generated fields
    signal_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    
    def __post_init__(self):
        """Validate the signal after initialization."""
        if self.urgency < 0.0 or self.urgency > 1.0:
            logger.warning(f"Signal urgency outside valid range [0.0, 1.0]: {self.urgency}. Clamping.")
            self.urgency = max(0.0, min(1.0, self.urgency))
        
        if self.ttl_seconds <= 0:
            logger.warning(f"Invalid ttl_seconds {self.ttl_seconds}. Setting to default 60.")
            self.ttl_seconds = 60
            
        # Ensure action is uppercase
        self.action = self.action.upper()

@dataclass
class ExecutionResult:
    """Result of a signal execution."""
    signal_id: str
    timestamp: datetime
    status: Literal["FILLED", "PARTIAL", "FAILED", "EXPIRED", "REJECTED"]
    filled_quantity: float
    executed_price: float
    fees: float
    latency_ms: int
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def is_successful(self) -> bool:
        """Check if the execution was successful (fully or partially filled)."""
        return self.status in ["FILLED", "PARTIAL"]
    
    def fill_percentage(self) -> float:
        """Calculate the percentage of the order that was filled."""
        if self.is_successful() and 'original_quantity' in self.metadata:
            original_qty = self.metadata['original_quantity']
            if original_qty > 0:
                return (self.filled_quantity / original_qty) * 100.0
        return 0.0 if self.status == "FAILED" else 100.0

@dataclass
class RiskProfile:
    """Risk parameters for a strategy."""
    max_risk_per_trade: float = 1.0  # Max % of portfolio to risk per trade
    max_drawdown: float = 10.0  # Max drawdown % allowed before auto-suspension
    max_position_size: float = 5.0  # Max position size as % of available capital
    use_stop_loss: bool = True
    stop_loss_pct: Optional[float] = 2.0
    use_take_profit: bool = True
    take_profit_pct: Optional[float] = 3.0
    additional_params: Dict[str, Any] = field(default_factory=dict)

class BaseStrategy(ABC):
    """Base class for all Python-defined strategies."""
    
    def __init__(self, strategy_id: str, parameters: Dict[str, Any] = None):
        """Initialize the strategy with its ID and parameters."""
        self.strategy_id = strategy_id
        self.parameters = parameters or {}
        self.state = {}
        self.last_execution = None
        self.risk_profile = RiskProfile()
        self._configure_risk_profile()
        
    def _configure_risk_profile(self):
        """Configure the risk profile based on parameters."""
        # Override default risk profile with parameters if provided
        for param, value in self.parameters.items():
            if hasattr(self.risk_profile, param):
                setattr(self.risk_profile, param, value)
    
    @abstractmethod
    async def analyze(self, market_data: MarketData) -> Optional[Signal]:
        """Analyze market data and decide whether to generate a signal."""
        raise NotImplementedError("Subclasses must implement analyze()")
    
    def on_execution_result(self, result: ExecutionResult) -> None:
        """Handle execution result feedback."""
        self.last_execution = result
        # Update internal state based on execution result
        self._update_state_from_execution(result)
    
    def _update_state_from_execution(self, result: ExecutionResult) -> None:
        """Update internal state based on execution result."""
        # Default implementation tracks total trades and success rate
        if 'trades_count' not in self.state:
            self.state['trades_count'] = 0
        
        if 'successful_trades' not in self.state:
            self.state['successful_trades'] = 0
            
        self.state['trades_count'] += 1
        if result.is_successful():
            self.state['successful_trades'] += 1
            
        # Calculate win rate
        if self.state['trades_count'] > 0:
            self.state['win_rate'] = (self.state['successful_trades'] / self.state['trades_count']) * 100.0
    
    def get_metadata(self) -> Dict[str, Any]:
        """Return metadata about this strategy for the DAO governance."""
        return {
            "id": self.strategy_id,
            "type": self.__class__.__name__,
            "parameters": self.parameters,
            "description": self.__doc__ or "No description provided",
            "last_updated": datetime.now().isoformat(),
            "trades_count": self.state.get('trades_count', 0),
            "win_rate": self.state.get('win_rate', 0.0),
            "risk_profile": {
                "max_risk_per_trade": self.risk_profile.max_risk_per_trade,
                "max_drawdown": self.risk_profile.max_drawdown,
                "max_position_size": self.risk_profile.max_position_size,
                "use_stop_loss": self.risk_profile.use_stop_loss,
                "stop_loss_pct": self.risk_profile.stop_loss_pct,
                "use_take_profit": self.risk_profile.use_take_profit,
                "take_profit_pct": self.risk_profile.take_profit_pct,
            }
        }
    
    def entropy_score(self) -> float:
        """
        Calculate how unpredictable this strategy is.
        Returns a value between 0.0 (completely predictable) and 1.0 (highly unpredictable).
        """
        # Default implementation based on timing variability of past trades
        if not hasattr(self, '_execution_times') or len(self._execution_times) < 10:
            return 0.5
            
        times = np.array(self._execution_times)
        
        # Calculate coefficient of variation (CV)
        std_dev = np.std(times)
        mean = np.mean(times)
        
        if mean == 0:
            return 0.5
            
        cv = std_dev / mean
        
        # Map CV to 0-1 range (higher CV means more randomness)
        entropy = min(1.0, cv / 2.0)
        
        return entropy 