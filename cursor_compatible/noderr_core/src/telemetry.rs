// SPDX-License-Identifier: MIT
//
// Copyright (c) 2025 Noderr Protocol Foundation
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

use std::collections::{HashMap, VecDeque};
use std::sync::{Arc, RwLock};
use std::time::{Duration, Instant};

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use thiserror::Error;
use tokio::sync::broadcast;
use tracing::{debug, error, info, warn};
use uuid::Uuid;

use crate::strategy::{Signal, Strategy, StrategyError};
use crate::execution::{ExecutionResult, ExecutionError};
use crate::risk::RiskError;

/// Errors that can occur in the telemetry system
#[derive(Debug, Error)]
pub enum TelemetryError {
    #[error("Broadcast channel error: {0}")]
    BroadcastError(String),
    
    #[error("Storage error: {0}")]
    StorageError(String),
    
    #[error("Serialization error: {0}")]
    SerializationError(String),
    
    #[error("Network error: {0}")]
    NetworkError(String),
    
    #[error("Invalid parameter: {0}")]
    InvalidParameter(String),
    
    #[error("Internal error: {0}")]
    Internal(String),
    
    #[error("Access denied: {0}")]
    AccessDenied(String),
}

/// Severity level for telemetry events
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum TelemetryLevel {
    Debug,
    Info,
    Warning,
    Error,
    Critical,
}

/// Types of telemetry events
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TelemetryEvent {
    /// A strategy execution has started
    ExecutionStart {
        /// Strategy ID
        strategy_id: String,
        /// Timestamp of the event
        timestamp: DateTime<Utc>,
    },
    /// No signal was generated by a strategy
    NoSignal {
        /// Strategy ID
        strategy_id: String,
        /// Timestamp of the event
        timestamp: DateTime<Utc>,
    },
    /// An error occurred during strategy execution
    StrategyError {
        /// Strategy ID
        strategy_id: String,
        /// Error message
        error: String,
        /// Timestamp of the event
        timestamp: DateTime<Utc>,
    },
    /// A risk limit was reached
    RiskLimit {
        /// Strategy ID
        strategy_id: String,
        /// Risk error details
        error: String,
        /// Timestamp of the event
        timestamp: DateTime<Utc>,
    },
    /// An execution error occurred
    ExecutionError {
        /// Strategy ID
        strategy_id: String,
        /// Execution error details
        error: String,
        /// Timestamp of the event
        timestamp: DateTime<Utc>,
    },
    /// An execution has completed
    ExecutionComplete {
        /// Strategy ID
        strategy_id: String,
        /// Execution result
        result: ExecutionResult,
        /// Timestamp of the event
        timestamp: DateTime<Utc>,
    },
    /// A trust score has been updated
    TrustScoreUpdate {
        /// Entity ID (strategy, node, etc.)
        entity_id: String,
        /// Entity type
        entity_type: String,
        /// New trust score
        new_score: f64,
        /// Previous trust score
        previous_score: f64,
        /// Reason for update
        reason: String,
        /// Timestamp of the event
        timestamp: DateTime<Utc>,
    },
    /// System metrics have been collected
    MetricsCollected {
        /// Metrics collected
        metrics: HashMap<String, f64>,
        /// Timestamp of the event
        timestamp: DateTime<Utc>,
    },
    /// Custom event with arbitrary data
    Custom {
        /// Event type
        event_type: String,
        /// Event data
        data: HashMap<String, serde_json::Value>,
        /// Timestamp of the event
        timestamp: DateTime<Utc>,
    },
}

impl TelemetryEvent {
    /// Get the timestamp of the event
    pub fn timestamp(&self) -> DateTime<Utc> {
        match self {
            Self::ExecutionStart { timestamp, .. } => *timestamp,
            Self::NoSignal { timestamp, .. } => *timestamp,
            Self::StrategyError { timestamp, .. } => *timestamp,
            Self::RiskLimit { timestamp, .. } => *timestamp,
            Self::ExecutionError { timestamp, .. } => *timestamp,
            Self::ExecutionComplete { timestamp, .. } => *timestamp,
            Self::TrustScoreUpdate { timestamp, .. } => *timestamp,
            Self::MetricsCollected { timestamp, .. } => *timestamp,
            Self::Custom { timestamp, .. } => *timestamp,
        }
    }
    
    /// Get the level of the event
    pub fn level(&self) -> TelemetryLevel {
        match self {
            Self::ExecutionStart { .. } => TelemetryLevel::Info,
            Self::NoSignal { .. } => TelemetryLevel::Debug,
            Self::StrategyError { .. } => TelemetryLevel::Error,
            Self::RiskLimit { .. } => TelemetryLevel::Warning,
            Self::ExecutionError { .. } => TelemetryLevel::Error,
            Self::ExecutionComplete { .. } => TelemetryLevel::Info,
            Self::TrustScoreUpdate { .. } => TelemetryLevel::Info,
            Self::MetricsCollected { .. } => TelemetryLevel::Debug,
            Self::Custom { .. } => TelemetryLevel::Info,
        }
    }
    
    /// Get the related entity ID (if any)
    pub fn entity_id(&self) -> Option<&str> {
        match self {
            Self::ExecutionStart { strategy_id, .. } => Some(strategy_id),
            Self::NoSignal { strategy_id, .. } => Some(strategy_id),
            Self::StrategyError { strategy_id, .. } => Some(strategy_id),
            Self::RiskLimit { strategy_id, .. } => Some(strategy_id),
            Self::ExecutionError { strategy_id, .. } => Some(strategy_id),
            Self::ExecutionComplete { strategy_id, .. } => Some(strategy_id),
            Self::TrustScoreUpdate { entity_id, .. } => Some(entity_id),
            Self::MetricsCollected { .. } => None,
            Self::Custom { .. } => None,
        }
    }
}

/// Configuration for the telemetry system
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TelemetryConfig {
    /// Maximum events to store in memory
    pub max_events: usize,
    /// Whether to enable broadcasting
    pub enable_broadcasting: bool,
    /// Maximum broadcast channel capacity
    pub broadcast_capacity: usize,
    /// Minimum level to log
    pub min_log_level: TelemetryLevel,
    /// Whether to persist events to disk
    pub enable_persistence: bool,
    /// Path to persistence directory
    pub persistence_path: Option<String>,
    /// Snapshot interval in seconds
    pub snapshot_interval_sec: u64,
}

impl Default for TelemetryConfig {
    fn default() -> Self {
        Self {
            max_events: 10000,
            enable_broadcasting: true,
            broadcast_capacity: 1000,
            min_log_level: TelemetryLevel::Info,
            enable_persistence: false,
            persistence_path: None,
            snapshot_interval_sec: 60,
        }
    }
}

/// A snapshot of session telemetry data
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SessionTelemetrySnapshot {
    /// Unique ID for this snapshot
    pub id: String,
    /// Timestamp when the snapshot was taken
    pub timestamp: DateTime<Utc>,
    /// Active strategies count
    pub active_strategies: usize,
    /// Recent event counts by level
    pub event_counts: HashMap<TelemetryLevel, usize>,
    /// Recent errors count
    pub error_count: usize,
    /// Trust scores by entity
    pub trust_scores: HashMap<String, f64>,
    /// System metrics
    pub metrics: HashMap<String, f64>,
    /// Session uptime in seconds
    pub uptime_seconds: u64,
}

/// Trust score data for an entity
#[derive(Debug, Clone, Serialize, Deserialize)]
struct TrustScore {
    /// Current trust score (0.0 to 1.0)
    score: f64,
    /// Base trust score (starting point for recovery)
    base_score: f64,
    /// Last update timestamp
    last_updated: DateTime<Utc>,
    /// Update history (recent changes)
    history: VecDeque<TrustScoreUpdate>,
}

/// A trust score update event
#[derive(Debug, Clone, Serialize, Deserialize)]
struct TrustScoreUpdate {
    /// Previous score
    previous: f64,
    /// New score
    new: f64,
    /// Reason for the update
    reason: String,
    /// When the update occurred
    timestamp: DateTime<Utc>,
}

/// Role-based access control roles for telemetry
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum TelemetryRole {
    /// Admin role with full access
    Admin,
    /// Operator role with access to operational metrics
    Operator,
    /// Developer role with access to development metrics
    Developer,
    /// Strategy owner role with access to owned strategy metrics
    StrategyOwner,
    /// Viewer role with limited access
    Viewer,
}

/// Permissions for telemetry data access
#[derive(Debug, Clone)]
pub struct TelemetryPermissions {
    /// Role of the user
    pub role: TelemetryRole,
    /// Can access metrics 
    pub can_access_metrics: bool,
    /// Can access detailed events
    pub can_access_events: bool,
    /// Can access trust scores
    pub can_access_trust_scores: bool,
    /// Can access trust history
    pub can_access_trust_history: bool,
    /// Filter strategy IDs (empty means all)
    pub strategy_ids: Vec<String>,
    /// Can access system-level metrics
    pub can_access_system_metrics: bool,
    /// Can access real-time websocket stream
    pub can_access_websocket: bool,
}

impl TelemetryPermissions {
    /// Create new permissions based on role
    pub fn new(role: TelemetryRole) -> Self {
        match role {
            TelemetryRole::Admin => Self {
                role,
                can_access_metrics: true,
                can_access_events: true,
                can_access_trust_scores: true,
                can_access_trust_history: true,
                strategy_ids: vec![],  // Empty means all
                can_access_system_metrics: true,
                can_access_websocket: true,
            },
            TelemetryRole::Operator => Self {
                role,
                can_access_metrics: true,
                can_access_events: true,
                can_access_trust_scores: true,
                can_access_trust_history: true,
                strategy_ids: vec![],  // Empty means all
                can_access_system_metrics: true,
                can_access_websocket: true,
            },
            TelemetryRole::Developer => Self {
                role,
                can_access_metrics: true,
                can_access_events: true,
                can_access_trust_scores: true, 
                can_access_trust_history: true,
                strategy_ids: vec![],  // Empty means all
                can_access_system_metrics: false,
                can_access_websocket: true,
            },
            TelemetryRole::StrategyOwner => Self {
                role,
                can_access_metrics: true,
                can_access_events: true,
                can_access_trust_scores: true,
                can_access_trust_history: true,
                strategy_ids: vec![],  // Will be set by for_strategy_owner
                can_access_system_metrics: false,
                can_access_websocket: true,
            },
            TelemetryRole::Viewer => Self {
                role,
                can_access_metrics: true,
                can_access_events: false,
                can_access_trust_scores: false,
                can_access_trust_history: false,
                strategy_ids: vec![],
                can_access_system_metrics: false,
                can_access_websocket: false,
            },
        }
    }

    /// Create permissions for specific strategy owner
    pub fn for_strategy_owner(strategy_id: &str) -> Self {
        let mut perms = Self::new(TelemetryRole::StrategyOwner);
        perms.strategy_ids = vec![strategy_id.to_string()];
        perms
    }

    /// Check if the user can access a specific strategy
    pub fn can_access_strategy(&self, strategy_id: &str) -> bool {
        match self.role {
            TelemetryRole::Admin | TelemetryRole::Operator | TelemetryRole::Developer => true,
            TelemetryRole::StrategyOwner => self.strategy_ids.contains(&strategy_id.to_string()),
            TelemetryRole::Viewer => false,
        }
    }
}

/// Trust buffer for historical trust data
struct TrustBuffer {
    /// Historical trust score updates
    updates: VecDeque<TrustScoreUpdate>,
    /// Maximum size of the buffer
    max_size: usize,
}

impl TrustBuffer {
    /// Create a new trust buffer
    fn new(max_size: usize) -> Self {
        Self {
            updates: VecDeque::with_capacity(max_size),
            max_size,
        }
    }
    
    /// Add a trust score update to the buffer
    fn add(&mut self, update: TrustScoreUpdate) {
        self.updates.push_front(update);
        
        while self.updates.len() > self.max_size {
            self.updates.pop_back();
        }
    }
    
    /// Get recent updates, optionally filtered by time range
    fn get_recent(&self, limit: Option<usize>) -> Vec<&TrustScoreUpdate> {
        let limit = limit.unwrap_or(self.updates.len());
        self.updates.iter().take(limit).collect()
    }
}

/// Manages telemetry events and trust scores
pub struct TelemetryReporter {
    /// Configuration for telemetry
    config: TelemetryConfig,
    /// Recent events
    events: Arc<RwLock<VecDeque<TelemetryEvent>>>,
    /// Trust scores by entity ID
    trust_scores: Arc<RwLock<HashMap<String, TrustScore>>>,
    /// System metrics
    metrics: Arc<RwLock<HashMap<String, f64>>>,
    /// Broadcast channel for events
    event_tx: broadcast::Sender<TelemetryEvent>,
    /// Session start time
    session_start: DateTime<Utc>,
    /// Last snapshot time
    last_snapshot: Arc<RwLock<DateTime<Utc>>>,
}

impl TelemetryReporter {
    /// Create a new telemetry reporter with the given configuration
    pub fn new(config: TelemetryConfig) -> Self {
        let (tx, _) = broadcast::channel(config.broadcast_capacity);
        let now = Utc::now();
        
        Self {
            config,
            events: Arc::new(RwLock::new(VecDeque::with_capacity(1000))),
            trust_scores: Arc::new(RwLock::new(HashMap::new())),
            metrics: Arc::new(RwLock::new(HashMap::new())),
            event_tx: tx,
            session_start: now,
            last_snapshot: Arc::new(RwLock::new(now)),
        }
    }
    
    /// Get a subscription to telemetry events
    pub fn subscribe(&self) -> broadcast::Receiver<TelemetryEvent> {
        self.event_tx.subscribe()
    }
    
    /// Report execution start
    pub async fn report_execution_start(&self, strategy_id: &str) {
        let event = TelemetryEvent::ExecutionStart {
            strategy_id: strategy_id.to_string(),
            timestamp: Utc::now(),
        };
        
        self.report_event(event).await;
    }
    
    /// Report no signal
    pub async fn report_no_signal(&self, strategy_id: &str) {
        let event = TelemetryEvent::NoSignal {
            strategy_id: strategy_id.to_string(),
            timestamp: Utc::now(),
        };
        
        self.report_event(event).await;
    }
    
    /// Report strategy error
    pub async fn report_error(&self, strategy_id: &str, error: &StrategyError) {
        let event = TelemetryEvent::StrategyError {
            strategy_id: strategy_id.to_string(),
            error: error.to_string(),
            timestamp: Utc::now(),
        };
        
        self.report_event(event).await;
        
        // Decrease trust score for strategy on error
        self.update_trust_score(
            strategy_id,
            "strategy",
            -0.05,
            format!("Strategy error: {}", error),
        ).await;
    }
    
    /// Report risk limit violation
    pub async fn report_risk_limit(&self, strategy_id: &str, error: &RiskError) {
        let event = TelemetryEvent::RiskLimit {
            strategy_id: strategy_id.to_string(),
            error: error.to_string(),
            timestamp: Utc::now(),
        };
        
        self.report_event(event).await;
        
        // Only slightly decrease trust score for risk limits (expected behavior)
        self.update_trust_score(
            strategy_id,
            "strategy",
            -0.02,
            format!("Risk limit: {}", error),
        ).await;
    }
    
    /// Report execution error
    pub async fn report_execution_error(&self, strategy_id: &str, error: &ExecutionError) {
        let event = TelemetryEvent::ExecutionError {
            strategy_id: strategy_id.to_string(),
            error: error.to_string(),
            timestamp: Utc::now(),
        };
        
        self.report_event(event).await;
        
        // Decrease trust score for execution errors
        self.update_trust_score(
            strategy_id,
            "strategy",
            -0.03,
            format!("Execution error: {}", error),
        ).await;
    }
    
    /// Report execution completion
    pub async fn report_execution_complete(&self, strategy_id: &str, result: &ExecutionResult) {
        let event = TelemetryEvent::ExecutionComplete {
            strategy_id: strategy_id.to_string(),
            result: result.clone(),
            timestamp: Utc::now(),
        };
        
        self.report_event(event).await;
        
        // Increase trust score for successful executions
        if result.is_success() {
            self.update_trust_score(
                strategy_id,
                "strategy",
                0.01,
                "Successful execution".to_string(),
            ).await;
        } else if result.is_failure() {
            self.update_trust_score(
                strategy_id,
                "strategy",
                -0.03,
                format!("Failed execution: {:?}", result.status),
            ).await;
        }
    }
    
    /// Report a custom event
    pub async fn report_custom(&self, event_type: &str, data: HashMap<String, serde_json::Value>) {
        let event = TelemetryEvent::Custom {
            event_type: event_type.to_string(),
            data,
            timestamp: Utc::now(),
        };
        
        self.report_event(event).await;
    }
    
    /// Report metrics collection
    pub async fn report_metrics(&self, metrics: HashMap<String, f64>) {
        // Update stored metrics
        {
            let mut current_metrics = self.metrics.write().unwrap();
            for (key, value) in &metrics {
                current_metrics.insert(key.clone(), *value);
            }
        }
        
        let event = TelemetryEvent::MetricsCollected {
            metrics,
            timestamp: Utc::now(),
        };
        
        self.report_event(event).await;
    }
    
    /// Internal method to report an event
    async fn report_event(&self, event: TelemetryEvent) {
        // Only process events that meet minimum level
        if event.level() < self.config.min_log_level {
            return;
        }
        
        // Store the event
        {
            let mut events = self.events.write().unwrap();
            events.push_back(event.clone());
            
            // Remove oldest events if exceeding capacity
            while events.len() > self.config.max_events {
                events.pop_front();
            }
        }
        
        // Log to tracing based on level
        match event.level() {
            TelemetryLevel::Debug => debug!("{:?}", event),
            TelemetryLevel::Info => info!("{:?}", event),
            TelemetryLevel::Warning => warn!("{:?}", event),
            TelemetryLevel::Error | TelemetryLevel::Critical => error!("{:?}", event),
        }
        
        // Broadcast if enabled
        if self.config.enable_broadcasting {
            if let Err(e) = self.event_tx.send(event) {
                error!("Failed to broadcast telemetry event: {}", e);
            }
        }
        
        // Check if snapshot is needed
        self.check_snapshot().await;
    }
    
    /// Check if a snapshot should be created
    async fn check_snapshot(&self) {
        let now = Utc::now();
        let mut last_snapshot = self.last_snapshot.write().unwrap();
        
        let elapsed_secs = (now - *last_snapshot).num_seconds() as u64;
        if elapsed_secs >= self.config.snapshot_interval_sec {
            *last_snapshot = now;
            drop(last_snapshot); // Release lock before creating snapshot
            
            if let Err(e) = self.create_snapshot().await {
                error!("Failed to create telemetry snapshot: {}", e);
            }
        }
    }
    
    /// Create a snapshot of current telemetry state
    async fn create_snapshot(&self) -> Result<SessionTelemetrySnapshot, TelemetryError> {
        // Count events by level
        let mut event_counts = HashMap::new();
        let mut error_count = 0;
        
        {
            let events = self.events.read().unwrap();
            for event in events.iter() {
                let level = event.level();
                *event_counts.entry(level).or_insert(0) += 1;
                
                if level == TelemetryLevel::Error || level == TelemetryLevel::Critical {
                    error_count += 1;
                }
            }
        }
        
        // Get trust scores
        let trust_scores = {
            let scores = self.trust_scores.read().unwrap();
            scores.iter()
                .map(|(id, score)| (id.clone(), score.score))
                .collect()
        };
        
        // Get current metrics
        let metrics = {
            let m = self.metrics.read().unwrap();
            m.clone()
        };
        
        // Calculate uptime
        let uptime_seconds = (Utc::now() - self.session_start).num_seconds().max(0) as u64;
        
        let snapshot = SessionTelemetrySnapshot {
            id: Uuid::new_v4().to_string(),
            timestamp: Utc::now(),
            active_strategies: trust_scores.iter()
                .filter(|(id, _)| id.starts_with("strategy:"))
                .count(),
            event_counts,
            error_count,
            trust_scores,
            metrics,
            uptime_seconds,
        };
        
        // In a real implementation, we would persist snapshots to disk or database
        if self.config.enable_persistence {
            // Placeholder for persistence logic
            debug!("Would persist snapshot {} to storage", snapshot.id);
        }
        
        Ok(snapshot)
    }
    
    /// Update trust score for an entity
    async fn update_trust_score(
        &self,
        entity_id: &str,
        entity_type: &str,
        delta: f64,
        reason: String,
    ) {
        let full_id = format!("{}:{}", entity_type, entity_id);
        let now = Utc::now();
        
        // Update trust score
        let (previous, new) = {
            let mut scores = self.trust_scores.write().unwrap();
            
            let score = scores.entry(full_id.clone()).or_insert_with(|| TrustScore {
                score: 0.5, // Default starting score
                base_score: 0.5,
                last_updated: now,
                history: VecDeque::with_capacity(100),
            });
            
            let previous = score.score;
            
            // Apply delta
            score.score = (score.score + delta).clamp(0.0, 1.0);
            
            // Update history
            score.history.push_front(TrustScoreUpdate {
                previous,
                new: score.score,
                reason: reason.clone(),
                timestamp: now,
            });
            
            // Keep history size reasonable
            while score.history.len() > 100 {
                score.history.pop_back();
            }
            
            score.last_updated = now;
            
            (previous, score.score)
        };
        
        // Create trust score update event
        let event = TelemetryEvent::TrustScoreUpdate {
            entity_id: full_id,
            entity_type: entity_type.to_string(),
            new_score: new,
            previous_score: previous,
            reason,
            timestamp: now,
        };
        
        // Report the event
        self.report_event(event).await;
    }
    
    /// Get trust score for an entity
    pub fn get_trust_score(&self, entity_id: &str, entity_type: &str) -> Option<f64> {
        let full_id = format!("{}:{}", entity_type, entity_id);
        let scores = self.trust_scores.read().unwrap();
        
        scores.get(&full_id).map(|score| score.score)
    }
    
    /// Get recent telemetry events, optionally filtered
    pub fn get_recent_events(
        &self,
        level: Option<TelemetryLevel>,
        entity_id: Option<&str>,
        limit: Option<usize>,
    ) -> Vec<TelemetryEvent> {
        let events = self.events.read().unwrap();
        let mut filtered: Vec<_> = events.iter()
            .filter(|event| {
                // Apply level filter
                if let Some(min_level) = level {
                    if event.level() < min_level {
                        return false;
                    }
                }
                
                // Apply entity ID filter
                if let Some(id) = entity_id {
                    if let Some(event_id) = event.entity_id() {
                        if event_id != id {
                            return false;
                        }
                    } else {
                        return false;
                    }
                }
                
                true
            })
            .cloned()
            .collect();
        
        // Sort by timestamp (newest first)
        filtered.sort_by(|a, b| b.timestamp().cmp(&a.timestamp()));
        
        // Apply limit
        if let Some(limit) = limit {
            filtered.truncate(limit);
        }
        
        filtered
    }
    
    /// Get the latest snapshot
    pub async fn get_latest_snapshot(&self) -> Result<SessionTelemetrySnapshot, TelemetryError> {
        self.create_snapshot().await
    }
    
    /// Public method to report direct trust state updates
    pub async fn report_trust_update(
        &self,
        strategy_id: &str,
        trust_score: f64,
        consecutive_losses: u32,
        is_active: bool,
    ) {
        // Create a reason message based on the provided information
        let reason = format!(
            "Strategy trust state update: score={}, consecutive_losses={}, active={}",
            trust_score, consecutive_losses, is_active
        );
        
        // Directly call the private update_trust_score method with strategy entity type
        self.update_trust_score(
            strategy_id,
            "strategy",
            // We use 0.0 for delta since we're providing the absolute score via other means
            0.0, 
            reason
        ).await;
        
        // Create and report a custom event with additional trust state details
        let mut data = HashMap::new();
        data.insert("trust_score".to_string(), serde_json::to_value(trust_score).unwrap());
        data.insert("consecutive_losses".to_string(), serde_json::to_value(consecutive_losses).unwrap());
        data.insert("is_active".to_string(), serde_json::to_value(is_active).unwrap());
        
        self.report_custom("trust_state_updated", data).await;
    }
    
    /// Filter events based on permissions
    pub fn filter_events(&self, events: Vec<TelemetryEvent>, permissions: &TelemetryPermissions) -> Vec<TelemetryEvent> {
        events.into_iter()
            .filter(|event| permissions.can_access_strategy(event.entity_id().unwrap()))
            .collect()
    }
    
    /// Get recent events with permission filtering
    pub fn get_recent_events_with_permissions(
        &self,
        level: Option<TelemetryLevel>,
        entity_id: Option<&str>,
        limit: Option<usize>,
        permissions: &TelemetryPermissions,
    ) -> Result<Vec<TelemetryEvent>, TelemetryError> {
        // Get events first using existing method
        let events = self.get_recent_events(level, entity_id, limit);
        
        // Then filter based on permissions
        Ok(self.filter_events(events, permissions))
    }
    
    /// Get trust scores with permission filtering
    pub fn get_trust_scores_with_permissions(
        &self,
        permissions: &TelemetryPermissions,
    ) -> Result<HashMap<String, f64>, TelemetryError> {
        if !permissions.can_access_trust_scores {
            return Err(TelemetryError::AccessDenied(
                "You do not have permission to access trust scores".to_string()
            ));
        }
        
        let scores = self.trust_scores.read().unwrap();
        let mut result = HashMap::new();
        
        for (id, score) in scores.iter() {
            // Filter by strategy ID if permissions are limited
            if !permissions.strategy_ids.is_empty() {
                if let Some(strategy_id) = id.strip_prefix("strategy:") {
                    if !permissions.strategy_ids.contains(&strategy_id.to_string()) {
                        continue;
                    }
                } else {
                    continue;
                }
            }
            
            result.insert(id.clone(), score.score);
        }
        
        Ok(result)
    }
    
    /// Get metrics with permission filtering
    pub fn get_metrics_with_permissions(
        &self,
        permissions: &TelemetryPermissions,
    ) -> Result<HashMap<String, f64>, TelemetryError> {
        if !permissions.can_access_metrics {
            return Err(TelemetryError::AccessDenied(
                "You do not have permission to access metrics".to_string()
            ));
        }
        
        let metrics = self.metrics.read().unwrap();
        Ok(metrics.clone())
    }
    
    /// Get snapshot with permission filtering
    pub async fn get_snapshot_with_permissions(
        &self,
        permissions: &TelemetryPermissions,
    ) -> Result<SessionTelemetrySnapshot, TelemetryError> {
        let mut snapshot = self.create_snapshot().await?;
        
        // Filter trust scores based on permissions
        if !permissions.can_access_trust_scores {
            snapshot.trust_scores.clear();
        } else if !permissions.strategy_ids.is_empty() {
            // Filter to only include authorized strategies
            snapshot.trust_scores.retain(|id, _| {
                if let Some(strategy_id) = id.strip_prefix("strategy:") {
                    permissions.strategy_ids.contains(&strategy_id.to_string())
                } else {
                    false
                }
            });
        }
        
        // Filter metrics based on permissions
        if !permissions.can_access_metrics {
            snapshot.metrics.clear();
        }
        
        Ok(snapshot)
    }
    
    /// Emit a soft warning about a strategy's trust score
    pub async fn emit_soft_warning(&self, strategy_id: &str, trust_score: f64, message: String) {
        let mut data = HashMap::new();
        data.insert("trust_score".to_string(), serde_json::to_value(trust_score).unwrap());
        data.insert("message".to_string(), serde_json::to_value(message).unwrap());
        data.insert("threshold".to_string(), serde_json::to_value("soft").unwrap());
        
        // Create and report a custom event
        self.report_custom("trust_soft_warning", data).await;
        
        debug!("Trust soft warning for strategy {}: {}", strategy_id, message);
    }
    
    /// Report a trust-based rejection
    pub async fn report_trust_rejection(&self, strategy_id: &str, rejection: &crate::strategy_executor::ExecutionRejection) {
        match rejection {
            crate::strategy_executor::ExecutionRejection::TrustGate { reason, score } => {
                let mut data = HashMap::new();
                data.insert("trust_score".to_string(), serde_json::to_value(score).unwrap());
                data.insert("reason".to_string(), serde_json::to_value(reason).unwrap());
                data.insert("threshold".to_string(), serde_json::to_value("hard").unwrap());
                
                // Create and report a trust rejection event
                self.report_custom("trust_hard_rejection", data).await;
                
                // Also create a TrustScoreUpdate event
                let event = TelemetryEvent::TrustScoreUpdate {
                    entity_id: format!("strategy:{}", strategy_id),
                    entity_type: "strategy".to_string(),
                    new_score: *score,
                    previous_score: *score, // Same as new since we're just reporting
                    reason: reason.clone(),
                    timestamp: Utc::now(),
                };
                
                // Report the event
                self.report_event(event).await;
                
                warn!("Trust rejection for strategy {}: {} (score: {:.2})", strategy_id, reason, score);
            },
            _ => {
                // For other rejection types, just log them
                debug!("Non-trust rejection for strategy {}: {:?}", strategy_id, rejection);
            }
        }
    }
    
    /// Report a governance rule violation
    pub async fn report_governance_violation(&self, strategy_id: &str, rejection: &crate::strategy_executor::ExecutionRejection) {
        match rejection {
            crate::strategy_executor::ExecutionRejection::GovernanceRule { reason, code, severity } => {
                let mut data = HashMap::new();
                data.insert("strategy_id".to_string(), serde_json::to_value(strategy_id).unwrap());
                data.insert("reason".to_string(), serde_json::to_value(reason).unwrap());
                data.insert("code".to_string(), serde_json::to_value(code).unwrap());
                data.insert("severity".to_string(), serde_json::to_value(severity).unwrap());
                
                // Create and report a governance violation event
                self.report_custom("governance_rule_violation", data).await;
                
                // Log the event based on severity
                match severity.as_str() {
                    "critical" => {
                        warn!("CRITICAL governance rule violation for strategy {}: {} (code: {})", 
                             strategy_id, reason, code);
                    },
                    "moderate" => {
                        info!("Moderate governance rule violation for strategy {}: {} (code: {})", 
                             strategy_id, reason, code);
                    },
                    _ => {
                        debug!("Mild governance rule violation for strategy {}: {} (code: {})", 
                              strategy_id, reason, code);
                    }
                }
            },
            _ => {
                // For other rejection types, just log them
                debug!("Non-governance rejection for strategy {}: {:?}", strategy_id, rejection);
            }
        }
    }
}

/// Start the telemetry system with default configuration
pub fn start_telemetry() -> TelemetryReporter {
    let config = TelemetryConfig::default();
    TelemetryReporter::new(config)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::Arc;
    
    #[tokio::test]
    async fn test_telemetry_events() {
        let config = TelemetryConfig {
            max_events: 100,
            enable_broadcasting: true,
            broadcast_capacity: 10,
            min_log_level: TelemetryLevel::Debug,
            enable_persistence: false,
            persistence_path: None,
            snapshot_interval_sec: 60,
        };
        
        let reporter = TelemetryReporter::new(config);
        
        // Report some events
        reporter.report_execution_start("test-strategy").await;
        reporter.report_no_signal("test-strategy").await;
        
        let error = StrategyError::InvalidParameter { 
            name: "param".to_string(), 
            reason: "invalid".to_string() 
        };
        reporter.report_error("test-strategy", &error).await;
        
        // Check events were recorded
        let events = reporter.get_recent_events(None, Some("test-strategy"), None);
        assert_eq!(events.len(), 3);
        
        // Check trust score was decreased
        let trust = reporter.get_trust_score("test-strategy", "strategy").unwrap();
        assert!(trust < 0.5); // Should be decreased from default 0.5
    }
    
    #[tokio::test]
    async fn test_trust_score_tracking() {
        let reporter = start_telemetry();
        
        // Update trust score
        reporter.update_trust_score(
            "test-entity",
            "test-type",
            0.1,
            "Test increase".to_string(),
        ).await;
        
        let score1 = reporter.get_trust_score("test-entity", "test-type").unwrap();
        assert!(score1 > 0.5);
        
        // Decrease trust score
        reporter.update_trust_score(
            "test-entity",
            "test-type",
            -0.2,
            "Test decrease".to_string(),
        ).await;
        
        let score2 = reporter.get_trust_score("test-entity", "test-type").unwrap();
        assert!(score2 < score1);
        
        // Verify events were created
        let events = reporter.get_recent_events(None, None, None);
        let trust_updates = events.iter()
            .filter(|e| matches!(e, TelemetryEvent::TrustScoreUpdate { .. }))
            .count();
        
        assert_eq!(trust_updates, 2);
    }
    
    #[tokio::test]
    async fn test_snapshot_creation() {
        let reporter = start_telemetry();
        
        // Add some events and metrics
        reporter.report_execution_start("test-strategy").await;
        
        let mut metrics = HashMap::new();
        metrics.insert("cpu_usage".to_string(), 45.2);
        metrics.insert("memory_mb".to_string(), 128.5);
        reporter.report_metrics(metrics).await;
        
        // Create snapshot
        let snapshot = reporter.get_latest_snapshot().await.unwrap();
        
        // Verify snapshot content
        assert!(snapshot.uptime_seconds >= 0);
        assert_eq!(snapshot.event_counts.get(&TelemetryLevel::Info).unwrap_or(&0), &2);
        assert_eq!(snapshot.metrics.get("cpu_usage").unwrap(), &45.2);
    }
    
    #[tokio::test]
    async fn test_permissions_filtering() {
        let reporter = start_telemetry();
        
        // Set up test data
        reporter.report_execution_start("strategy-1").await;
        reporter.report_execution_start("strategy-2").await;
        
        let error = StrategyError::InvalidParameter { 
            name: "param".to_string(), 
            reason: "invalid".to_string() 
        };
        reporter.report_error("strategy-1", &error).await;
        
        // Test admin permissions (can see everything)
        let admin_perms = TelemetryPermissions::new(TelemetryRole::Admin);
        let admin_events = reporter.get_recent_events_with_permissions(
            None, None, None, &admin_perms
        ).unwrap();
        assert_eq!(admin_events.len(), 3);
        
        // Test strategy owner permissions (limited to one strategy)
        let mut owner_perms = TelemetryPermissions::new(TelemetryRole::StrategyOwner);
        owner_perms.add_strategy("strategy-1");
        
        let owner_events = reporter.get_recent_events_with_permissions(
            None, None, None, &owner_perms
        ).unwrap();
        
        // Should only see events for strategy-1 (2 events)
        let strategy_1_events = owner_events.iter()
            .filter(|e| e.entity_id() == Some("strategy-1"))
            .count();
            
        assert_eq!(strategy_1_events, 2);
        
        // Test viewer permissions (limited access, no trust scores)
        let viewer_perms = TelemetryPermissions::new(TelemetryRole::Viewer);
        
        let trust_scores = reporter.get_trust_scores_with_permissions(&viewer_perms);
        assert!(trust_scores.is_err());
        assert!(matches!(trust_scores.unwrap_err(), TelemetryError::AccessDenied(_)));
    }
} 