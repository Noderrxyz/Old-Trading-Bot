// SPDX-License-Identifier: MIT
//
// Copyright (c) 2025 Noderr Protocol Foundation
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

use std::fmt;
use serde::{Serialize, Deserialize};
use std::time::Duration;

/// Types of leading indicators monitored for regime shifts
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum LeadingIndicator {
    /// Sudden spike in volatility (realized or implied)
    VolatilitySpike,
    
    /// Reversal in momentum indicators (MACD, RSI)
    MomentumReversal,
    
    /// Anomalous volume patterns (CVD, OBV)
    VolumeAnomaly,
    
    /// Sharp shifts in social sentiment
    SocialSentiment,
    
    /// Significant imbalance in order book depth
    OrderBookSkew,
}

impl fmt::Display for LeadingIndicator {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            LeadingIndicator::VolatilitySpike => write!(f, "VOLATILITY_SPIKE"),
            LeadingIndicator::MomentumReversal => write!(f, "MOMENTUM_REVERSAL"),
            LeadingIndicator::VolumeAnomaly => write!(f, "VOLUME_ANOMALY"),
            LeadingIndicator::SocialSentiment => write!(f, "SOCIAL_SENTIMENT"),
            LeadingIndicator::OrderBookSkew => write!(f, "ORDER_BOOK_SKEW"),
        }
    }
}

/// Direction of the indicator's potential effect on market regime
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum IndicatorDirection {
    /// Indicator suggests transition to bullish regime
    Bullish,
    
    /// Indicator suggests transition to bearish regime
    Bearish,
    
    /// Indicator suggests transition to volatile regime
    Volatile,
    
    /// Indicator suggests transition to sideways regime
    Sideways,
    
    /// Direction is unclear
    Undefined,
}

impl fmt::Display for IndicatorDirection {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            IndicatorDirection::Bullish => write!(f, "BULLISH"),
            IndicatorDirection::Bearish => write!(f, "BEARISH"),
            IndicatorDirection::Volatile => write!(f, "VOLATILE"),
            IndicatorDirection::Sideways => write!(f, "SIDEWAYS"),
            IndicatorDirection::Undefined => write!(f, "UNDEFINED"),
        }
    }
}

/// Warning signal generated by a leading indicator
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RegimeWarning {
    /// The indicator that triggered the warning
    pub indicator: LeadingIndicator,
    
    /// Symbol this warning applies to
    pub symbol: String,
    
    /// Current value of the indicator
    pub value: f64,
    
    /// Threshold that was crossed
    pub threshold: f64,
    
    /// Confidence level in the warning (0.0-1.0)
    pub confidence: f64,
    
    /// Timestamp when the warning was generated
    pub timestamp: chrono::DateTime<chrono::Utc>,
    
    /// Likely direction of regime shift
    pub direction: IndicatorDirection,
    
    /// Estimated time until the regime shift (in seconds)
    pub estimated_time_to_shift: Option<u64>,
    
    /// Metadata about the warning
    pub metadata: Option<serde_json::Value>,
}

impl RegimeWarning {
    /// Create a new regime warning
    pub fn new(
        indicator: LeadingIndicator,
        symbol: &str,
        value: f64,
        threshold: f64,
        confidence: f64,
        direction: IndicatorDirection,
    ) -> Self {
        Self {
            indicator,
            symbol: symbol.to_string(),
            value,
            threshold,
            confidence,
            timestamp: chrono::Utc::now(),
            direction,
            estimated_time_to_shift: None,
            metadata: None,
        }
    }
    
    /// Add estimated time to regime shift
    pub fn with_estimated_time(&mut self, seconds: u64) -> &mut Self {
        self.estimated_time_to_shift = Some(seconds);
        self
    }
    
    /// Add metadata to the warning
    pub fn with_metadata(&mut self, metadata: serde_json::Value) -> &mut Self {
        self.metadata = Some(metadata);
        self
    }
    
    /// Get the Redis channel for this warning
    pub fn redis_channel(&self) -> String {
        format!("regime:warning:{}", self.indicator)
    }
}

/// Configuration for a leading indicator
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IndicatorConfig {
    /// Threshold value that triggers a warning
    pub threshold: f64,
    
    /// Cooldown period after a warning (in seconds)
    pub cooldown_sec: u64,
    
    /// Warning decay period (in seconds)
    pub decay_sec: u64,
    
    /// Whether to enable this indicator
    pub enabled: bool,
    
    /// Minimum confidence required to trigger a warning
    pub min_confidence: f64,
}

impl Default for IndicatorConfig {
    fn default() -> Self {
        Self {
            threshold: 2.0,        // 2 standard deviations
            cooldown_sec: 600,     // 10 minutes
            decay_sec: 1800,       // 30 minutes
            enabled: true,
            min_confidence: 0.65,  // 65% confidence
        }
    }
}

/// A forecast of the potential next market regime
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RegimeForecast {
    /// Symbol this forecast applies to
    pub symbol: String,
    
    /// Current market regime state
    pub current_regime: crate::market_regime::MarketRegimeState,
    
    /// Probabilities of each potential next regime
    pub forecast: std::collections::HashMap<crate::market_regime::MarketRegimeState, f64>,
    
    /// Confidence in the forecast (0.0-1.0)
    pub confidence: f64,
    
    /// Timestamp when the forecast was generated
    pub timestamp: chrono::DateTime<chrono::Utc>,
    
    /// Estimated time until the regime shift (in seconds)
    pub estimated_time_to_shift: Option<u64>,
    
    /// Indicators that contributed to this forecast
    pub contributing_indicators: Vec<LeadingIndicator>,
}

impl RegimeForecast {
    /// Create a new regime forecast
    pub fn new(
        symbol: &str,
        current_regime: crate::market_regime::MarketRegimeState,
        forecast: std::collections::HashMap<crate::market_regime::MarketRegimeState, f64>,
        confidence: f64,
    ) -> Self {
        Self {
            symbol: symbol.to_string(),
            current_regime,
            forecast,
            confidence,
            timestamp: chrono::Utc::now(),
            estimated_time_to_shift: None,
            contributing_indicators: Vec::new(),
        }
    }
    
    /// Add estimated time to regime shift
    pub fn with_estimated_time(&mut self, seconds: u64) -> &mut Self {
        self.estimated_time_to_shift = Some(seconds);
        self
    }
    
    /// Add a contributing indicator
    pub fn add_contributing_indicator(&mut self, indicator: LeadingIndicator) -> &mut Self {
        self.contributing_indicators.push(indicator);
        self
    }
    
    /// Get the most likely next regime
    pub fn most_likely_regime(&self) -> (crate::market_regime::MarketRegimeState, f64) {
        let mut max_prob = 0.0;
        let mut max_regime = self.current_regime;
        
        for (regime, prob) in &self.forecast {
            if *prob > max_prob {
                max_prob = *prob;
                max_regime = *regime;
            }
        }
        
        (max_regime, max_prob)
    }
}

/// Strategy preparation signal for regime transitions
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StrategyPrepSignal {
    /// Forecast regime state
    pub forecast_regime: crate::market_regime::MarketRegimeState,
    
    /// Symbol this signal applies to
    pub symbol: String,
    
    /// Confidence in the forecast (0.0-1.0)
    pub confidence: f64,
    
    /// Actions to take (strategy IDs to warm up or cool down)
    pub actions: Vec<StrategyPrepAction>,
    
    /// Timestamp when the signal was generated
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

/// Types of strategy preparation actions
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum StrategyPrepAction {
    /// Warm up a strategy for potential activation
    #[serde(rename = "warmup")]
    Warmup(String),
    
    /// Cool down a strategy for potential deactivation
    #[serde(rename = "cooldown")]
    Cooldown(String),
}

impl StrategyPrepSignal {
    /// Create a new strategy prep signal
    pub fn new(
        forecast_regime: crate::market_regime::MarketRegimeState,
        symbol: &str,
        confidence: f64,
    ) -> Self {
        Self {
            forecast_regime,
            symbol: symbol.to_string(),
            confidence,
            actions: Vec::new(),
            timestamp: chrono::Utc::now(),
        }
    }
    
    /// Add a warmup action
    pub fn add_warmup(&mut self, strategy_id: &str) -> &mut Self {
        self.actions.push(StrategyPrepAction::Warmup(strategy_id.to_string()));
        self
    }
    
    /// Add a cooldown action
    pub fn add_cooldown(&mut self, strategy_id: &str) -> &mut Self {
        self.actions.push(StrategyPrepAction::Cooldown(strategy_id.to_string()));
        self
    }
} 